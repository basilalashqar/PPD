Overview

In this project, our team embarked on the design and implementation of a Pipelined Processor using Logisim, with a focus on a Reduced Instruction Set Computing (RISC) architecture. The primary objective was to develop a high-performance processor capable of executing instructions in a pipelined fashion, thereby enhancing overall throughput and efficiency.


Design Choices and Notable Features

We initiated the project by designing a single-cycle CPU, laying the foundation for our subsequent pipelined processor. The single-cycle CPU encompassed critical components such as the program counter (PC), instruction memory, register file, main control unit, and arithmetic logic unit (ALU). This stage allowed us to establish a solid understanding of basic CPU architecture and operation.
Building upon the single-cycle CPU, we transitioned to developing a pipelined processor architecture. Our pipelined design incorporated multiple stages including instruction fetch (IF), instruction decode (ID), execute (EX), memory access (MEM), and write back (WB). This architectural shift aimed to exploit instruction-level parallelism, enabling the simultaneous execution of multiple instructions and thereby boosting performance.

Description of Control Logic and Signals

The control logic within our pipelined processor played a pivotal role in orchestrating the flow of instructions and data across various pipeline stages. Control signals generated by the main control unit and forwarding logic unit ensured seamless coordination among CPU components. Additionally, comprehensive handling of control hazards and data hazards was implemented to guarantee correct instruction execution and mitigate potential pipeline stalls.

Description of Forwarding Logic and Control Hazard Handling

To address data hazards inherent in pipelined architectures, we incorporated sophisticated forwarding logic. This technique facilitated the seamless transfer of data between pipeline stages, minimizing the impact of hazards such as read-after-write (RAW) dependencies. Furthermore, effective control hazard handling mechanisms were devised to navigate branching and control flow instructions, ensuring accurate program execution while maximizing pipeline efficiency.

Simulation and Testing

The design and functionality of our pipelined processor were rigorously evaluated through extensive simulation and testing procedures. Various test programs, including Count Ones, Short, Bubble Sort, and All Instructions, were employed to validate the processor's performance across diverse instruction sets and scenarios. These tests provided valuable insights into the effectiveness of our design choices and highlighted areas for optimization and refinement.
